use crate::board::Board;
use crate::board::Pos;
use crate::board::Move;
use crate::moves::pin;

fn can_drop(b:&Board, can:bool)->bool {
	assert_eq!(b.valid(), 0, "{b:?}");
	let mut uiter = b.moves_unbound();
	while let Some(mv) = uiter.next(&b) {
		assert!(b.legal(mv), "{mv:?}");
		if mv == (Move{
			from:Pos{x:9, y:4},
			to:Pos{x:0, y:1},
			prmt:false
		}) {return can}
	}
	return !can;
}

#[test] fn pawn_drop_0() {
	let b = Board::from("|
	........K
	.........
	........g
	.........
	.........
	.........
	.........
	.........
	.........
	|p");
	assert!(can_drop(&b, true));
}

#[test] fn pawn_drop_1() {
	let b = Board::from("|
	........K
	.........
	........g
	........p
	.........
	.........
	.........
	.........
	.........
	|p");
	assert!(can_drop(&b, false));
}

#[test] fn pawn_drop_2() {
	let b = Board::from("|
	........K
	......z..
	........g
	.........
	.........
	.........
	.........
	.........
	.........
	|p");
	assert!(can_drop(&b, false));
}

#[test] fn pawn_drop_3() {
	let b = Board::from("|
	.......GK
	......z..
	........g
	.........
	.........
	.........
	.........
	.........
	.........
	|p");
	assert!(can_drop(&b, true));
}

#[test] fn pawn_drop_4() {
	let b = Board::from("|
	u......GK
	......z..
	........g
	.........
	.........
	.........
	.........
	.........
	.........
	|p");
	assert!(can_drop(&b, false));
}

fn iff_legal(s:&str) {
	fn check(b:&Board, mvs:Vec<Move>) {
		for tx in 0 .. 9 {
			for ty in 0 .. 9 {				
				for fx in 0 .. 9 {
					for fy in 0 .. 9 {
						for prmt in [false, true] {
							let mv = Move{
								from:Pos{x:fx, y:fy},
								to:Pos{x:tx, y:ty},
								prmt,
							};
							assert_eq!(mvs.contains(&mv), b.legal(mv), "{mv:?}, {}", b.turn);
						}
					}
				}
				
				for fx in [9, 10] {
					for fy in 0 .. 7 {
						let mv = Move{
							from:Pos{x:fx, y:fy},
							to:Pos{x:tx, y:ty},
							prmt:false,
						};
						assert_eq!(mvs.contains(&mv), b.legal(mv), "{mv:?}, {}", b.turn);
					}
				}
			}
		}
	}
	
	let mut b = Board::from(s);
	assert_eq!(b.valid(), 0, "{b:?}");
	check(&b, b.moves().collect());
	b.turn ^= true;
	if b.valid() == 0 {
		check(&b, b.moves().collect());
	}
}

#[test] fn legitimacy_0() {
	iff_legal("|
	u......GK
	......z..
	......a.g
	.........
	.........
	.........
	.........
	.........
	.........
	|p");
}

#[test] fn legitimacy_1() {
	iff_legal("APPPPPP|
	R.h...c.R
	..D.dG...
	P..P...P.
	..P.Pg..K
	...A.P..P
	..pkp.a..
	p.g..pd.p
	..g......
	r...c..ar
	|hd");
}

#[test] fn legitimacy_2() {
	iff_legal("GDPC|
	R.......R
	KP..g....
	A..P....P
	P.D.P..d.
	a........
	.apv....p
	p.g.ppap.
	......pk.
	rU.H.g..r
	|dppppp");
}

#[test] fn king_capture_check_0() {
	let b = Board::from("|
	R........
	.........
	.........
	.........
	.........
	.........
	.A.......
	.u.......
	kp.......
	|AARRDD");
	assert_eq!(b.moves().count(), 0, "{:?}", b.moves().collect::<Vec<_>>());
}

#[test] fn king_capture_check_1() {
	let b = Board::from("|
	R........
	.........
	.........
	.........
	.........
	.........
	.........
	Xu.......
	kp.......
	|AARRDD");
	assert_eq!(b.moves().count(), 1, "{:?}", b.moves().collect::<Vec<_>>());
}

#[test] fn king_capture_check_2() {
	let b = Board::from("G|
	.........
	.........
	.........
	.........
	.........
	.AH......
	ppd......
	k........
	ra.......
	|AARRDD");
	assert_eq!(b.moves().count(), 2, "{:?}", b.moves().collect::<Vec<_>>());
}

#[test] fn king_capture_check_3() {
	let b = Board::from("|
	H........
	.........
	.........
	.........
	.........
	.........
	.........
	.........
	........k
	|GGGG");
	assert_eq!(b.moves().count(), 9, "{:?}", b.moves().collect::<Vec<_>>());
}

#[test] fn king_capture_check_4() {
	let b = Board::from("|
	.........
	.........
	.........
	.........
	.........
	P........
	C........
	ka.......
	.........
	|");
	assert_eq!(b.moves().count(), 1, "{:?}", b.moves().collect::<Vec<_>>());
}

#[test] fn king_capture_check_5() {
	let b = Board::from("|
	...KD....
	...G.....
	..au.....
	.........
	.........
	.........
	.........
	.........
	.........
	|!");
	assert_eq!(b.moves().count(), 1, "{:?}", b.moves().collect::<Vec<_>>());
}

#[test] fn promote_0() {
	let b = Board::from("|
	.........
	.........
	.........
	........d
	.........
	.........
	.........
	.........
	.........
	|");
	assert_eq!(b.moves().count(), 5, "{:?}", b.moves().collect::<Vec<_>>());
}

#[test] fn promote_1() {
	let b = Board::from("|
	.........
	.........
	........d
	.........
	.........
	.........
	.........
	.........
	.........
	|");
	assert_eq!(b.moves().count(), 6, "{:?}", b.moves().collect::<Vec<_>>());
}

#[test] fn pin_0() {
	let mut b = Board::from("|
	........K
	.......G.
	.........
	.....h...
	.........
	.....H...
	.........
	.......g.
	........k
	|");
	
	assert_eq!(b.pinned(Pos{x:1, y:7}, true, Pos{x:0, y:8}), pin::NEG);
	let mv_good = Move{from:Pos{x:1, y:7}, to:Pos{x:2, y:6}, prmt:false};
	let mv_bad = Move{from:Pos{x:1, y:7}, to:Pos{x:0, y:6}, prmt:false};
	assert!(b.legal(mv_good));
	assert!(!b.legal(mv_bad));
	let mvs = b.moves().collect::<Vec<_>>();
	assert!(mvs.contains(&mv_good));
	assert!(!mvs.contains(&mv_bad));
	
	b.turn ^= true;
	
	assert_eq!(b.pinned(Pos{x:1, y:1}, false, Pos{x:0, y:0}), pin::POS);
	let mv_good = Move{from:Pos{x:1, y:1}, to:Pos{x:2, y:2}, prmt:false};
	let mv_bad = Move{from:Pos{x:1, y:1}, to:Pos{x:0, y:2}, prmt:false};
	assert!(b.legal(mv_good));
	assert!(!b.legal(mv_bad));
	let mvs = b.moves().collect::<Vec<_>>();
	assert!(mvs.contains(&mv_good));
	assert!(!mvs.contains(&mv_bad));
}

#[test] fn pin_1() {
	let b = Board::from("|
	........R
	........g
	........k
	........g
	........R
	.........
	.........
	.........
	.........
	|");
	
	assert_eq!(b.pinned(Pos{x:0, y:1}, true, Pos{x:0, y:2}), pin::VRT);
	assert_eq!(b.pinned(Pos{x:0, y:3}, true, Pos{x:0, y:2}), pin::NO);
	let mv_good = Move{from:Pos{x:0, y:3}, to:Pos{x:1, y:3}, prmt:false};
	let mv_bad = Move{from:Pos{x:0, y:1}, to:Pos{x:1, y:1}, prmt:false};
	assert!(b.legal(mv_good));
	assert!(!b.legal(mv_bad));
	let mvs = b.moves().collect::<Vec<_>>();
	assert!(mvs.contains(&mv_good));
	assert!(!mvs.contains(&mv_bad));
}

#[test] fn pin_2() {
	let b = Board::from("|
	.........
	.........
	...C.....
	...a.....
	...p.....
	...k.....
	.........
	.........
	.........
	|");
	
	assert_eq!(b.pinned(Pos{x:5, y:3}, true, Pos{x:5, y:5}), pin::NO);
	assert_eq!(b.pinned(Pos{x:5, y:4}, true, Pos{x:5, y:5}), pin::NO);
}

fn will_check(s:&str) {
	let b = Board::from(s);
	
	for mv in b.moves() {
		assert!(b.legal(mv), "{mv:?}");
		let will_check = b.will_check(mv);
		let mut b = b.clone();
		b.do_move(mv);
		assert_eq!(b.valid(), 0);
		assert_eq!(will_check, b.checks(), "{mv:?}");
	}
}

#[test] fn will_check_1() {
	will_check("
	APPPPPP|
	R.h...c.R
	..D.dG...
	P..P...P.
	..P.Pg..K
	...A.P.aP
	..pkp.h..
	p.g..pd.p
	..g......
	r...c..ar
	|d");
}

#[test] fn will_check_2() {
	will_check("
	APPPPPP|
	R.h...c.R
	..D.dG...
	P..P...P.
	..P.Pg..K
	...A.P..P
	..pkp.a..
	p.g..pd.p
	..g......
	r...c..ar
	|hd");
}

#[test] fn will_check_3() {
	will_check("
	GDDRP|
	...yh....
	....K..d.
	...P...Px
	...GPP..P
	.........
	.........
	.........
	.........
	.........
	|gr");
}

#[test] fn will_check_4() {
	will_check("
	DAPPPPPP|
	R.h...c.R
	..D.dG...
	P..P...P.
	..P.Pg..K
	...A.P..P
	..pkp.a.h
	p.g..pd.p
	..g......
	r...c..ar
	|");
}

#[test] fn will_check_5() {
	will_check("
	HCAPPPPPP|
	R.h......
	..D.dG...
	P..P...P.
	..P.Pg..R
	...A.PK.P
	..pkp.a..
	p.g..pd.p
	..g......
	r...c..ar
	|d");
}